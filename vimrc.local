" General
filetype plugin indent on   " Automatically detect file types.
syntax on                   " Syntax highlighting
set mouse=a                 " Automatically enable mouse usage
set mousehide               " Hide the mouse cursor while typing
set encoding=utf-8
scriptencoding utf-8
" set shellcmdflag=-ic

" spellbad
" Force to use underline for spell check results
augroup SpellUnderline
    autocmd!
    autocmd ColorScheme *
                \ highlight SpellBad
                \   cterm=Underline
                \   ctermfg=NONE
                \   ctermbg=NONE
                \   term=Reverse
                \   gui=Undercurl
                \   guisp=Red
    autocmd ColorScheme *
                \ highlight SpellCap
                \   cterm=Underline
                \   ctermfg=NONE
                \   ctermbg=NONE
                \   term=Reverse
                \   gui=Undercurl
                \   guisp=Red
    autocmd ColorScheme *
                \ highlight SpellLocal
                \   cterm=Underline
                \   ctermfg=NONE
                \   ctermbg=NONE
                \   term=Reverse
                \   gui=Undercurl
                \   guisp=Red
    autocmd ColorScheme *
                \ highlight SpellRare
                \   cterm=Underline
                \   ctermfg=NONE
                \   ctermbg=NONE
                \   term=Reverse
                \   gui=Undercurl
                \   guisp=Red
augroup END
" gruvbox | PaperColor | molokai | dracula | onehalfdark | base16 family 
" hybrid_{reverse|material} | base16-snazzy | base16-oceanic | bluewey | nord
colorscheme molokai
set background=dark
if exists('+termguicolors')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set termguicolors
endif
if (!match(g:colors_name, "gruvbox"))
elseif (!match(g:colors_name, "dracula"))
elseif (!match(g:colors_name, "molokai"))
    let g:molokai_original = 1
    let g:rehash256 = 1
elseif (!match(g:colors_name, "PaperColor"))
elseif (!match(g:colors_name, "onehalfdark"))
    let g:airline_theme='onehalfdark'
    echo g:colors_name
elseif (!match(g:colors_name, "badwolf"))
    " Make the gutters darker than the background.
    let g:badwolf_darkgutter = 1
    " 1 / 2 / 3 / 4
    let g:badwolf_tabline = 4
    let g:badwolf_html_link_underline = 1
    " Turn on CSS properties highlighting
    let g:badwolf_css_props_highlight = 1
elseif (!match(g:colors_name, "hybrid_reverse"))
elseif (!match(g:colors_name, "base16-snazzy"))
    GOTO B16
elseif (!match(g:colors_name, "base16-oceanic"))
    GOTO B16
elseif (!match(g:colors_name, "bluewery"))
    let g:lightline = { 'colorscheme': 'bluewery' }
elseif (!match(g:colors_name, "base16-nord"))
    GOTO B16
elseif (!match(g:colors_name, "base16"))
LABEL B16:
    let base16colorspace=256  " Access colors present in 256 colorspace
    function! s:base16_customize() abort
        call Base16hi("MatchParen", g:base16_gui05, g:base16_gui03, g:base16_cterm05, g:base16_cterm03, "bold,italic", "")
    endfunction

    augroup on_change_colorschema
        autocmd!
        autocmd ColorScheme * call s:base16_customize()
    augroup END
endif

set autoread
" set autowrite
set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
set virtualedit=onemore             " Allow for cursor beyond last character
set history=5000                    " Store a ton of history (default is 20)
set spell                           " Spell checking on
set spell spelllang=en_us
set hidden                          " Allow buffer switching without saving
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
set iskeyword-=-                    " '-' is an end of word designator

" UI
let g:mapleader = ','
set tabpagemax=20               " Only show 15 tabs
set showmode                    " Display the current mode
set cursorline                  " Highlight current line
" highlight clear SignColumn      " SignColumn should match background
highlight clear LineNr          " Current line
set backspace=indent,eol,start  " Backspace for dummies
set linespace=0                 " No extra spaces between rows
set number                      " Line numbers on
set showmatch                   " Show matching brackets/parenthesis
set incsearch                   " Find as you type search
set hlsearch                    " Highlight search terms
set winminheight=0              " Windows can be 0 line high
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set foldenable                  " Auto fold code
set list
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

" Formatting
set nowrap                      " Do not wrap long lines
set autoindent                  " Indent at the same level of the previous line
set shiftwidth=4                " Use indents of 4 spaces
set expandtab                   " Tabs are spaces, not tabs
set tabstop=4                   " An indentation every four columns
set softtabstop=4               " Let backspace delete indent
set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
set splitright                  " Puts new vsplit windows to the right of the current
set splitbelow                  " Puts new split windows to the bottom of the current
set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)

" Code folding options
nmap <leader>f0 :set foldlevel=0<CR>
nmap <leader>f1 :set foldlevel=1<CR>
nmap <leader>f2 :set foldlevel=2<CR>
nmap <leader>f3 :set foldlevel=3<CR>
nmap <leader>f4 :set foldlevel=4<CR>
nmap <leader>f5 :set foldlevel=5<CR>
nmap <leader>f6 :set foldlevel=6<CR>
nmap <leader>f7 :set foldlevel=7<CR>
nmap <leader>f8 :set foldlevel=8<CR>
nmap <leader>f9 :set foldlevel=9<CR>

" basic
set hls
set tw=80
set rnu
set cindent
set autochdir
set linebreak
set laststatus=2
set noerrorbells
set noautoindent
set visualbell
set cursorcolumn
set nocompatible
set completeopt=longest,menu
set foldmethod=syntax
set foldlevelstart=99
set colorcolumn=+1,+2
" highlight ColorColumn ctermbg=lightgrey guibg=lightgrey
" relative number.vim
function! ScrollToggle()
    if &so == 0
        se so=999
        " call NumbersRelativeOff()
    else
        se so=0
        " set relativenumber
    endif
endfunction
nnoremap <F3> :call ScrollToggle()<CR>
nnoremap <Leader>p :registers<CR>

" op
nnoremap <CR> @=((foldclosed(line( '.' )) < 0)? 'zc' : 'zo')<CR>
nmap ; :
nnoremap <C-l> <c-w>l
nnoremap <C-h> <c-w>h
nnoremap <C-j> <c-w>j
nnoremap <C-k> <c-w>k
inoremap <C-l> <Right>
inoremap <C-h> <Left>
inoremap <C-j> <Down>
inoremap <C-k> <Up>
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-n> <m-o>
nnoremap <Leader>// :qa!<CR>
nnoremap <Leader>/W :w !sudo tee %<CR>
inoremap <C-z> <Esc>ddk$a
nnoremap <Silent><Leader>q gwip
inoremap <c-b> <c-right>
inoremap <c-v> <c-left>
nnoremap <ESC> :noh<CR>
function! AnyToggle()
    call Fcitx2en()
    set relativenumber
endfunction
inoremap <C-C> <C-C>:call AnyToggle()<CR>

" terminal
if has('nvim')
    nnoremap <Leader>ra :terminal<CR>i
    tnoremap <m-q> <c-\><c-n>
endif

" buffer switch
nnoremap <Leader>bn :bn<CR>
nnoremap <Leader>bp :bp<CR>
nnoremap <Leader>bd :bd<Space>
nnoremap <Leader>bc :bd<CR>
nnoremap <Leader>bl :blast<CR>
nnoremap <Leader>bf :bfirst<CR>
nnoremap <Leader>bb :Buffers<CR>
nnoremap <Leader>re :!<Space>
nnoremap <Leader>rw :r!<Space>
nnoremap <Leader>rr :AsyncRun -raw<Space>
nnoremap <Leader>b0 :buffers<CR>:bb<Space>
nnoremap <Leader>b1 :b1<CR>
nnoremap <Leader>b2 :b2<CR>
nnoremap <Leader>b3 :b3<CR>
nnoremap <Leader>b4 :b4<CR>
nnoremap <Leader>b5 :b5<CR>
nnoremap <Leader>b6 :b6<CR>
nnoremap <Leader>b7 :b7<CR>
nnoremap <Leader>b8 :b8<CR>
nnoremap <Leader>b9 :b9<CR>

" tab swtich
if !has('gui_running')
set showtabline=1
nnoremap <Leader>te :tabedit<Space>
nnoremap <Leader>tN :tabnew<CR>
" nnoremap <Leader>ta :tabs<CR>
nnoremap <Leader>ta :CocList windows<CR>
" 可以使用Ctrl-pgdn和Ctrl-pgup来代替
nnoremap <Leader>tn :tabnext<CR>
nnoremap <Leader>tp :tabNext<CR>
nnoremap <Leader>tf :tabfirst<CR>
nnoremap <Leader>tl :tablast<CR>
nnoremap <Leader>tx :tabclose<CR>
nnoremap <Leader>to :tabo<CR>
nnoremap <Leader>tm :tabmove<Space>
nnoremap <Leader>tdo :tabdo<Space>
nnoremap <Leader>tP :tab split<CR>
nnoremap <Leader>tw :e<Space>
nnoremap <Leader>ts :sp<Space>
nnoremap <Leader>tv :vsp<Space>
nnoremap <Leader>tu :diffsplit<Space>
nnoremap <Leader>tts :sp<CR>:terminal<CR>i
nnoremap <Leader>ttv :vsp<CR>:terminal<CR>i
nnoremap <Leader>1 1gt
nnoremap <Leader>2 2gt
nnoremap <Leader>3 3gt
nnoremap <Leader>4 4gt
nnoremap <Leader>5 5gt
nnoremap <Leader>6 6gt
nnoremap <Leader>7 7gt
nnoremap <Leader>8 8gt
nnoremap <Leader>9 9gt
nnoremap <Leader>0 10gt
" alt+n or alt+shift+n to "<ESC>]{0}n~"
noremap <silent><ESC>]{0}1~ 1gt
noremap <silent><ESC>]{0}2~ 2gt
noremap <silent><ESC>]{0}3~ 3gt
noremap <silent><ESC>]{0}4~ 4gt
noremap <silent><ESC>]{0}5~ 5gt
noremap <silent><ESC>]{0}6~ 6gt
noremap <silent><ESC>]{0}7~ 7gt
noremap <silent><ESC>]{0}8~ 8gt
noremap <silent><ESC>]{0}9~ 9gt
noremap <silent><ESC>]{0}0~ 10gt
inoremap <silent><ESC>]{0}1~ <ESC>1gt
inoremap <silent><ESC>]{0}2~ <ESC>2gt
inoremap <silent><ESC>]{0}3~ <ESC>3gt
inoremap <silent><ESC>]{0}4~ <ESC>4gt
inoremap <silent><ESC>]{0}5~ <ESC>5gt
inoremap <silent><ESC>]{0}6~ <ESC>6gt
inoremap <silent><ESC>]{0}7~ <ESC>7gt
inoremap <silent><ESC>]{0}8~ <ESC>8gt
inoremap <silent><ESC>]{0}9~ <ESC>9gt
inoremap <silent><ESC>]{0}0~ <ESC>10gt
endif

" python
let g:pymode_python = 'python3'
let g:python_host_prog = '/usr/bin/python'
let g:python3_host_prog = '/usr/bin/python3'
let g:ruby_host_prog = '/usr/bin/ruby'
"let g:node_host_prog = '/usr/bin/node'

" 远程vim与tmux联动的响应延迟
"if $TMUX != ''
"set ttimeoutlen=20
"elseif &ttimeoutlen > 60 || &ttimeoutlen <= 0
"set ttimeoutlen=60
"endif

" open folder
noremap <F8> :! dolphin . &<CR><CR>

" make tabline in terminal mode
function! Vim_NeatTabLine()
    let s = ''
    for i in range(tabpagenr('$'))
        " select the highlighting
        if i + 1 == tabpagenr()
            let s .= '%#TabLineSel#'
        else
            let s .= '%#TabLine#'
        endif
        " set the tab page number (for mouse clicks)
        let s .= '%' . (i + 1) . 'T'
        " the label is made by MyTabLabel()
        let s .= ' %{Vim_NeatTabLabel(' . (i + 1) . ')} '
    endfor
    " after the last tab fill with TabLineFill and reset tab page nr
    let s .= '%#TabLineFill#%T'
    " right-align the label to close the current tab page
    if tabpagenr('$') > 1
        let s .= '%=%#TabLine#%999XX'
    endif
    return s
endfunc
 
" get a single tab name 
function! Vim_NeatBuffer(bufnr, fullname)
    let l:name = bufname(a:bufnr)
    if getbufvar(a:bufnr, '&modifiable')
        if l:name == ''
            return '[No Name]'
        else
            if a:fullname 
                return fnamemodify(l:name, ':p')
            else
                return fnamemodify(l:name, ':t')
            endif
        endif
    else
        let l:buftype = getbufvar(a:bufnr, '&buftype')
        if l:buftype == 'quickfix'
            return '[Quickfix]'
        elseif l:name != ''
            if a:fullname 
                return '-'.fnamemodify(l:name, ':p')
            else
                return '-'.fnamemodify(l:name, ':t')
            endif
        else
        endif
        return '[No Name]'
    endif
endfunc
 
" get a single tab label
function! Vim_NeatTabLabel(n)
    let l:buflist = tabpagebuflist(a:n)
    let l:winnr = tabpagewinnr(a:n)
    let l:bufnr = l:buflist[l:winnr - 1]
    return Vim_NeatBuffer(l:bufnr, 0)
endfunc

" setup new tabline, just like %M%t in macvim
set tabline=%!Vim_NeatTabLine()

" PlugInstall ------------------------------------
" read pdf
" :command! -complete=file -nargs=1 Rpdf :r !pdftotext -nopgbrk <q-args> -
" :command! -complete=file -nargs=1 Rpdf :r !pdftotext -nopgbrk <q-args> - |fmt -csw78

" rust crate hinting
highlight Crates ctermfg=green ctermbg=NONE cterm=NONE
" or link it to another highlight group
highlight link Crates WarningMsg
" Automatically run :CratesToggle when opening a Cargo.toml file
if has('nvim')
  autocmd BufRead Cargo.toml call crates#toggle()
endif

" vimspector
" let g:vimspector_enable_mappings = 'HUMAN'

" quickui
let g:guickui_color_scheme = 'borland'
" 清楚所有目录项目
call quickui#menu#reset()
" 安装一个 File 目录，使用 [名称，命令] 的格式表示各个选项。
call quickui#menu#install('&File', [
            \ [ "&New File\tL-te", 'call feedkeys(":tabe ")' ],
            \ [ "&Open File\t;w", 'echo 1' ],
            \ [ "&Close\tL-/", "q" ],
            \ [ "--", '' ],
            \ [ "&Save\tCtrl+s", 'echo 3'],
            \ [ "Save &As", 'echo 4' ],
            \ [ "Save All", 'echo 5' ],
            \ [ "--", '' ],
            \ [ "E&xit\tAlt+x", 'echo 6' ],
            \ ])
" 每个项目还可以多包含一个字段，表示它的帮助文档，光标过去时会被显示到最下方的命令行
call quickui#menu#install('&Edit', [
            \ [ '&Copy', 'echo 1', 'help 1' ],
            \ [ '&Paste', 'echo 2', 'help 2' ],
            \ [ '&Find', 'echo 3', 'help 3' ],
            \ ])
" 在 %{...} 内的脚本会被求值并展开成字符串
call quickui#menu#install("&Option", [
			\ ['Set &Spell %{&spell? "Off":"On"}', 'set spell!'],
			\ ['Set &Cursor Line %{&cursorline? "Off":"On"}', 'set cursorline!'],
			\ ['Set &Paste %{&paste? "Off":"On"}', 'set paste!'],
			\ ])
" install 命令最后可以加一个“权重”系数，
" 用于决定目录位置，权重越大越靠右，越小越靠左
call quickui#menu#install('H&elp', [
			\ ["&Cheatsheet", 'help index', ''],
			\ ['T&ips', 'help tips', ''],
			\ ['--',''],
			\ ["&Tutorial", 'help tutor', ''],
			\ ['&Quick Reference', 'help quickref', ''],
			\ ['&Summary', 'help summary', ''],
			\ ], 10000)
" 打开下面选项，允许在 vim 的下面命令行部分显示帮助信息
let g:quickui_show_tip = 1
" 定义按两次空格就打开上面的目录
noremap <space><space> :call quickui#menu#open()<cr>

" zenroom2
nnoremap <Leader>zz :Goyo<CR>

" smooth-scroll
noremap <silent> <c-u> :call smooth_scroll#up(&scroll, 2, 5)<CR>
noremap <silent> <c-d> :call smooth_scroll#down(&scroll, 2, 5)<CR>
noremap <silent> <c-y> :call smooth_scroll#up(&scroll*2, 5, 10)<CR>
noremap <silent> <c-e> :call smooth_scroll#down(&scroll*2, 5, 10)<CR>

" ici
if has('nvim')
    nmap <Leader>yy :AsyncTask ici<CR>
    nmap <Leader>ys :AsyncTask ici-word<CR>
else
    nmap <Leader>yy :! echo --==<C-R><C-W>==--; ici <C-R><C-W><CR>
    nmap <Leader>ys :! echo "--==<NONE>==--"; ici<Space>
endif

" surround
nmap <Leader>sw ysiw
nmap <Leader>sl yss
nmap <Leader>sh cst
nmap <Leader>sr cs
" di与ds
" i模式下<C-S>a[rb]：添加b
" v模式下S可以替换

" markdown-preview
if has('nvim')
    let g:mkdp_auto_start = 0
    let g:mkdp_auto_close = 1
    let g:mkdp_refresh_slow = 0
    let g:mkdp_command_for_global = 1
    let g:mkdp_open_to_the_world = 1
    " 自定义IP打开预览页：https://github.com/iamcco/markdown-preview.nvim/pull/9 
    let g:mkdp_open_ip = ''
    let g:mkdp_browser = '/usr/bin/google-chrome-stable'
    let g:mkdp_echo_preview_url = 0
    let g:mkdp_browserfunc = ''
    let g:mkdp_preview_options = {
                \ 'mkit': {},
                \ 'katex': {},
                \ 'uml': {},
                \ 'puml': {},
                \ 'maid': {},
                \ 'disable_sync_scroll': 0,
                \ 'sync_scroll_type': 'middle',
                \ 'hide_yaml_meta': 1,
                \ 'sequence_diagrams': {},
                \ 'flowchart_diagrams': {}
                \ }
    let g:mkdp_markdown_css = ''
    let g:mkdp_highlight_css = ''
    let g:mkdp_port = '12305'
    " let g:mkdp_page_title = '「${name}」'
else
    " 默认浏览器
    let g:mkdp_path_to_chrome = '/usr/bin/google-chrome-stable'
    let g:mkdp_auto_start = 0
    let g:mkdp_auto_open = 0
    let g:mkdp_auto_close = 1
    let g:mkdp_refresh_slow = 0
    let g:mkdp_command_for_global = 0
    let g:mkdp_open_to_the_world = 1
endif
nnoremap <Leader>um :MarkdownPreview<CR>
nnoremap <Leader>un :MarkdownPreviewStop<CR>

" previm
let g:previm_open_cmd = 'plantuml'

" plantuml-previewer
let g:plantuml_previewer#save_format = 'png'
" let g:plantuml_previewer#viewr_path = ''
nnoremap <Leader>us :PlantumlSave<Space>
nnoremap <Leader>uo :PlantumlOpen<CR>

if exists("g:loaded_dzfplantuml_syntax")
    finish
endif
let g:loaded_dzfplantuml_syntax = 1
" 对 plantuml 文件绘制图片
function! UmlImageUpdate() abort
    " 先保存再执行命令
    let cmd = "w | !plantuml " . fnameescape(expand('%:t'))
    exec cmd
endfunction
" 对 plantuml 文件绘制图片, 并调用缺省的图片浏览器进行查看
function! UmlImageShow() abort
    let l:viewer='xdg-open'
    if has('mac')
        let l:viewer='open'
    endif
    call UmlImageUpdate()
    exec '!'.l:viewer.' '.expand('%:r').'.png'
endfunction
com! -nargs=0 UmlImageUpdate :call UmlImageUpdate()
com! -nargs=0 ViewUmlImage :call UmlImageShow()
" nnoremap <silent><buffer><leader>uu :UmlImageUpdate<CR><CR>
nnoremap <silent><buffer><leader>uv :ViewUmlImage<CR><CR><CR>

" startify
"设置书签
let g:startify_bookmarks = [
            \ '~/.vimrc.local',
            \]
"起始页显示的列表长度
let g:startify_files_number = 20
"自动加载session
let g:startify_session_autoload = 1
"过滤列表，支持正则表达式
let g:startify_skiplist = [
       \ '^/tmp',
       \ ]
"自定义Header和Footer
let g:startify_custom_header = [
            \ '+------------------------------+',
            \ '|                              |',
            \ '|    Still waters run deep!    |',
            \ '|                              |',
            \ '+----------------+-------------+',
            \]
let g:startify_custom_footer = [
            \ '+------------------------------+',
            \ '|     Keep an open mind!       |',
            \ '+----------------+-------------+',
            \]
noremap <F7> :Startify<CR>

" indent-guides
let g:indent_guides_enable_on_vim_startup=1
let g:indent_guides_start_level=2
let g:indent_guides_guide_size=1
nmap <Leader>i <Plug>IndentGuidesToggle
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=2
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=6
let g:indent_guides_indent_levels = 100
" let g:indent_guides_color_change_percent = 10
let g:indent_guides_guide_size = 1
" let g:indent_guides_exclude_filetypes = ['help', 'nerdtree']

" Sessionman
let sessionman_save_on_exit = 1
set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
nmap <leader>sel :SessionList<CR>
nmap <leader>ses :SessionSave<CR>
nmap <leader>sec :SessionClose<CR>

" numbers
" let g:numbers_exclude = ['tagbar', 'gundo', 'minibufexpl', 'nerdtree', 'defx']
let g:numbers_exclude = ['nerdtree']
nmap <silent><Leader>,, :<C-u>NumbersToggle<CR>

" rainbow
let g:rainbow_active = 1

" tarbar
let g:tagbar_width = 40
let g:tagbar_autopreview = 0
let g:tagbar_left = 1
let g:tagbar_vertical = 0
let g:tagbar_sort = 0
let g:tagbar_compact = 1
let g:tagbar_autofocus = 1
map <M-q> :TagbarToggle<CR>

" nerdtree
map <M-W> :NERDTreeTabsToggle<CR>
"map <leader>e :NERDTreeFind<CR>
"nmap <leader>nt :NERDTreeFind<CR>
let NERDTreeWinPos="right"
let NERDTreeShowBookmarks=1
let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
let NERDTreeChDirMode=0
let NERDTreeQuitOnOpen=1
let NERDTreeMouseMode=2
let NERDTreeShowHidden=1
let NERDTreeKeepTreeInNewTab=0
let g:nerdtree_tabs_open_on_gui_startup=0
" 打开vim如果没有文件自动打开nerdtree
" autocmd vimenter * if !argc()|NERDTree|endif
" 当nerdtree为最后窗口时自动关闭
"autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
" nerdtree自动查找并选择当前打开的文件
let g:nerdtree_tabs_autofind = 1
let g:nerdtree_tabs_focus_on_files = 1
" nerdtree中显示git信息
let g:NERDTreeIndicatorMapCustom = {
            \ "Modified"  : "✹",
            \ "Staged"    : "✚",
            \ "Untracked" : "✭",
            \ "Renamed"   : "➜",
            \ "Unmerged"  : "═",
            \ "Deleted"   : "✖",
            \ "Dirty"     : "✗",
            \ "Clean"     : "✔︎",
            \ "Unknown"   : "?"
            \ }

" autoformat
noremap <F6> :Autoformat<CR>
let g:autoformat_verbosemode = 1
set fo=aw2tq
" "g:formatdef_clangformat

" nerdcommenter
" 注释定界符后面加上空格
let g:NERDSpaceDelims = 1
" 多行注释使用紧凑语法
let g:NERDCompactSexyComs = 1
" 注释左对齐而不是代码对其
let g:NERDDefaultAlign = 'left'
" 自定义
" let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
" 是否允许空白行注释
" let g:NERDCommentEmptyLines = 1
" 是否嵌套的注释
" let g:NERDTrimTrailingWhitespace = 1
" 检查选中的所有行
let g:NERDToggleCheckAllLines = 1

" easymotion
nmap <Space> <Plug>(easymotion-overwin-f)
let g:EasyMotion_use_smartsign_us = 1 " US layout
let g:EasyMotion_startofline = 0 " keep cursor column when JK motion
let g:EasyMotion_smartcase = 1
" let g:EasyMotion_use_upper = 1 " 总是将键转换成大写字母，这将导致s无法跳转
let g:EasyMotion_do_mapping = 0 " Disable default mappings
"nmap s <Plug>(easymotion-overwin-f2)

" auto-pairs
" default 飞行模式（这里没有M-e键）
" let g:AutoPairsFlyMode = 0
" let g:AutoPairsShortcutBackInsert = '<M-b>'
" 对于inoremap <C-H>会有冲突，默认是1
let g:AutoPairsMapCh = 0

" undotree
"set backup
"set backupdir=~/.cache/.backup/
set noswapfile
"set directory=~/.cache/.swap/
set undofile
set undodir=~/.cache/.undo/
set undolevels=10000
set undoreload=10000
nnoremap <Leader>nu :UndotreeToggle<CR>
let g:undotree_SetFocusWhenToggle=1

" ctags
set tags=./.tags;,.tags
" spf13
" set tags=./tags;/,~/.vimtags
" Make tags placed in .git/tags file available in all levels of a repository
" let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
" if gitroot != ''
"     let &tags = &tags . ',' . gitroot . '/.git/tags'
" endif

" tabular
nmap <Leader>a& :Tabularize /&<CR>
vmap <Leader>a& :Tabularize /&<CR>
nmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
vmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
nmap <Leader>a=> :Tabularize /=><CR>
vmap <Leader>a=> :Tabularize /=><CR>
nmap <Leader>a: :Tabularize /:<CR>
vmap <Leader>a: :Tabularize /:<CR>
nmap <Leader>a:: :Tabularize /:\zs<CR>
vmap <Leader>a:: :Tabularize /:\zs<CR>
nmap <Leader>a, :Tabularize /,<CR>
vmap <Leader>a, :Tabularize /,<CR>
nmap <Leader>a,, :Tabularize /,\zs<CR>
vmap <Leader>a,, :Tabularize /,\zs<CR>
nmap <Leader>a; :Tabularize /;\zs<CR>
vmap <Leader>a; :Tabularize /;\zs<CR>
"nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
"vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
nmap <Leader>aa :Tabularize /
vmap <Leader>aa :Tabularize /
"nmap <Leader>a; :Tabularize /^[^;]*\zs,/r0c0l0
nmap <Leader>ai :Tabularize //r0c0l0
vmap <Leader>ai :Tabularize //r0c0l0
nmap <Leader>ao :Tabularize //r1c1l0
vmap <Leader>ao :Tabularize //r1c1l0
nmap <Leader>ar :Tabularize //l0
vmap <Leader>ar :Tabularize //l0
nmap <Leader>al :Tabularize //r0
vmap <Leader>al :Tabularize //r0
nmap <Leader>ab :Tabularize /^[^ ]*\zs /r0c0l0
vmap <Leader>ab :Tabularize /^[^ ]*\zs /r0c0l0

" fugitive
nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gd :Gdiff<CR>
nnoremap <silent> <leader>gc :Gcommit<CR>
nnoremap <silent> <leader>gb :Gblame<CR>
nnoremap <silent> <leader>gl :Glog<CR>
nnoremap <silent> <leader>gp :Git push<CR>
nnoremap <silent> <leader>gr :Gread<CR>
nnoremap <silent> <leader>gw :Gwrite<CR>
nnoremap <silent> <leader>ge :Gedit<CR>
nnoremap <silent> <leader>gg :! tig<CR>
nnoremap <silent> <leader>gi :Git add -p %<CR>

" airline
let g:airline_powerline_fonts = 1
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
set t_Co=256
let g:airline_theme="dark"
let g:airline#extensions#tabline#enabled = 1
"let g:airline_left_sep = '▶'
"let g:airline_left_alt_sep = '❯'
"let g:airline_right_sep = '◀'
"let g:airline_right_alt_sep = '❮'
" Powerline symbols: unicode
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.branch = '⎇'
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '∥'
let g:airline_symbols.whitespace = 'Ξ'
" Powerline symbols: powerline fonts
let irline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = ''

" SnipMate
let g:snipMate = get(g:, 'snipMate', {}) " Allow for vimrc re-sourcing
let g:snipMate.scope_aliases = {}
let g:snipMate.scope_aliases['ruby'] = 'ruby,rails'
" ??
" Setting the author var. If forking, please overwrite in your .vimrc.local file
" let g:snips_author = 'Steve Francia <steve.francia@gmail.com>'
" Snippets'
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
"let g:SuperTabDefaultCompletionType = '<C-n>'

" 语法高亮
" vim-cpp-enhanced-hightlight
" POSIX功能突出显示
let g:cpp_posix_standard = 1
" 模板功能突出显示
let g:cpp_experimental_simple_template_highlight = 1
" 声明类名显示高亮
let g:cpp_class_decl_highlight = 1
" 不突出显示类的范围
let g:cpp_class_scope_highlight = 1
" 库的突出显示
let g:cpp_concepts_highlight = 1
" 禁止显示用户定义的功能
"let g:cpp_no_function_highlight = 1

" gutentags
" gutentags 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归
let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']
" 所生成的数据文件的名称
let g:gutentags_ctags_tagfile = '.tags'
" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录
let s:vim_tags = expand('~/.cache/tags')
let g:gutentags_cache_dir = s:vim_tags
" 配置 ctags 的参数
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
" 检测 ~/.cache/tags 不存在就新建
if !isdirectory(s:vim_tags)
    silent! call mkdir(s:vim_tags, 'p')
endif

" AsyncRun
" terminal mode: tab/curwin/top/bottom/left/right/quickfix/external
let g:asynctasks_term_pos = 'quickfix'
" 放置标签覆盖
set switchbuf=useopen,usetab,newtab
" 自动打开quickfix window
let g:asyncrun_open = 10
let g:asyncrun_bell = 1
let g:asynctasks_term_rows = 20
let g:asynctasks_term_cols = 30
" 向上递归，遇到以下文件则视为项目目录
let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml']
" 在项目主目录生成.tags
" ctags -R --c++-kinds=+p --fields=+iaS --extras=+q --output-format=e-ctags -f ./.tags
" set tags=./.tags;,.tags
nnoremap <Leader>ri :AsyncTask ctags-update<CR>
nnoremap <silent><C-\> :call asyncrun#quickfix_toggle(6)<CR>
map <F10> <Leader>ri<C-W><C-]><C-\>
" 单文件编译运行
nnoremap <Leader>mr :AsyncTask file-run<CR>
nnoremap <Leader>mra :AsyncTask file-run-arg<CR>
nnoremap <Leader>mc :AsyncTask file-drop<CR>
nnoremap <Leader>md :AsyncTask file-build-debug<CR>
nnoremap <Leader>mb :AsyncTask file-build<CR>
" 项目文件编译运行
nnoremap <Leader>mcc :AsyncTask cmake-file-build<CR>
" 可以是make run，要先cmake配置add_custom_target
nnoremap <Leader>mca :AsyncTask make-file-build<CR>
nnoremap <Leader>mcb :AsyncTask make-file-build-debug<CR>
nnoremap <Leader>mct :AsyncTask make-file-test<CR>
nnoremap <Leader>mcd :AsyncTask make-file-clean<CR>
" make运行当前文件程序
nnoremap <Leader>mcr :AsyncTask make-run-program<CR>
" make运行某个可执行程序
nnoremap <Leader>mcrr :AsyncTask make-run-program-is<CR>

" AsyncTask
" quickfix、vim、tab、top、bottom、left、right、external
let g:asynctasks_term_pos="bottom"
let g:asynctasks_term_focus=0
let g:asynctasks_term_reuse=1
let g:asynctasks_confirm=1
let g:asynctasks_template = {}
let g:asynctasks_template.cargo = [
            \ "[project-init]",
            \ "command=cargo update",
            \ "cwd=<root>",
            \ "",
            \ "[project-build]",
            \ "command=cargo build",
            \ "cwd=<root>",
            \ "errorformat=%. %#--> %f:%l:%c",
            \ "",
            \ "[project-run]",
            \ "command=cargo run",
            \ "cwd=<root>",
            \ "output=terminal",
            \ ]
nnoremap <Leader>eel :AsyncTaskEdit<CR>
nnoremap <Leader>eeg :AsyncTaskEdit!<CR>
nnoremap <Leader>ec :AsyncTaskMacro<CR>
nnoremap <Leader>el :AsyncTaskList<CR>
nnoremap <Leader>eq :AsyncTask<Space>

function! s:lf_task_source(...)
	let rows = asynctasks#source(&columns * 48 / 100)
	let source = []
	for row in rows
		let name = row[0]
		let source += [name . '  ' . row[1] . '  : ' . row[2]]
	endfor
	return source
endfunction

function! s:lf_task_accept(line, arg)
	let pos = stridx(a:line, '<')
	if pos < 0
		return
	endif
	let name = strpart(a:line, 0, pos)
	let name = substitute(name, '^\s*\(.\{-}\)\s*$', '\1', '')
	if name != ''
		exec "AsyncTask " . name
	endif
endfunction

function! s:lf_task_digest(line, mode)
	let pos = stridx(a:line, '<')
	if pos < 0
		return [a:line, 0]
	endif
	let name = strpart(a:line, 0, pos)
	return [name, 0]
endfunction

function! s:lf_win_init(...)
	setlocal nonumber
	setlocal nowrap
endfunction

let g:Lf_Extensions = get(g:, 'Lf_Extensions', {})
let g:Lf_Extensions.task = {
            \ 'source': string(function('s:lf_task_source'))[10:-3],
            \ 'accept': string(function('s:lf_task_accept'))[10:-3],
            \ 'get_digest': string(function('s:lf_task_digest'))[10:-3],
            \ 'highlights_def': {
            \     'Lf_hl_funcScope': '^\S\+',
            \     'Lf_hl_funcDirname': '^\S\+\s*\zs<.*>\ze\s*:',
            \ },
            \ }

" browser
" use google chrome instaad of default broswer
" let g:openbrowser_browser_commands = [
"             \   {'name': '/usr/bin/firefox',
"             \    'args': ['start', '{browser}', '{uri}']}
"             \]
" 搜索引擎：google、baidu、bing、mijisou
let g:openbrowser_default_search = 'mijisou'
let g:openbrowser_search_engines = {
            \   'baidu': 'https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd={query}',
            \   'google': 'https://www.google.com/search?&q={query}&ie=utf-8',
            \   'mijisou': 'https://mijisou.com/?q={query}&category_general=on&time_range=&language=zh-CN&pageno=1',
            \   'bing': 'https://cn.bing.com/search?q={query}&qs=n&sp=-1',
            \}
nnoremap <Leader>hh :OpenBrowser<Space>
nnoremap <Leader>hs :OpenBrowserSmartSearch<Space>-baidu<Space>
vmap hs <Plug>(openbrowser-smart-search)
" with AsyncTask
nnoremap <silent><Leader>hf :AsyncTask browser-open-firefox<CR>
nnoremap <silent><Leader>hc :AsyncTask browser-open-chrome<CR>

" doxygen
let g:DoxygenToolkit_briefTag_pre="@brief  "
let g:DoxygenToolkit_paramTag_pre="@param  "
let g:DoxygenToolkit_returnTag="@return   "
" let g:DoxygenToolkit_blockHeader="--------------------------------------------------------------------------"
" let g:DoxygenToolkit_blockFooter="----------------------------------------------------------------------------"
let g:DoxygenToolkit_authorName="Ichheit, <ichheit@outlook.com>"
let s:licenseTag="\<enter>"
let s:licenseTag = s:licenseTag . "Copyright © 2020 .\<enter>"
let s:licenseTag = s:licenseTag . "For Free\<enter>"
let s:licenseTag = s:licenseTag . "All right Reserved."
let g:DoxygenToolkit_licenseTag=s:licenseTag
let g:DoxygenToolkit_briefTag_funcName="yes"
let g:doxygen_enhanced_color=1
nnoremap <Leader>za :DoxAuthor<CR>
nnoremap <Leader>zf :Dox<CR>
nnoremap <Leader>zl :DoxLic<CR>

" ale
" let g:ale_linters_explicit = 1
let g:ale_completion_delay = 500
let g:ale_echo_delay = 20
let g:ale_lint_delay = 500
let g:ale_echo_msg_format = '[%linter%] %code: %%s'
let g:ale_lint_on_text_changed = 'normal'
let g:ale_lint_on_insert_leave = 1
let g:airline#extensions#ale#enabled = 1
let g:ale_c_gcc_options = '-Wall -O2 -std=c99'
let g:ale_cpp_gcc_options = '-Wall -O2 -std=c++17'
let g:ale_c_cppcheck_options = ''
let g:ale_cpp_cppcheck_options = ''
" 使用clang对c和c++进行语法检查，对python使用pylint进行语法检查
let g:ale_linters = {
            \   'c++': ['clang'],
            \   'c': ['clang'],
            \   'python': ['pylint'],
            \}

" echodoc
" set noshowmode
" " let g:echodoc#type = "echo" " Default value
" " let g:echodoc_enable_at_startup = 1
" let g:echodoc#enable_at_startup = 1
" let g:echodoc#type = 'popup'
" " set cmdheight=1
" highlight link EchoDocPopup Pmenu

" LeaderF
let g:Lf_HideHelp = 1
let g:Lf_UseCache = 0
let g:Lf_UseVersionControlTool = 0
let g:Lf_IgnoreCurrentBufferName = 1
let g:Lf_RootMarkers = ['.project', '.root', '.svn', '.git', '.hg']
let g:Lf_WorkingDirectoryMode = 'Ac'
let g:Lf_WindowHeight = 0.30
let g:Lf_CacheDirectory = expand('~/.vim/cache')
let g:Lf_ShowRelativePath = 0
let g:Lf_StlColorscheme = 'powerline'
" let g:Lf_WindowPosition = 'popup'
let g:Lf_PreviewInPopup = 1
let g:Lf_StlSeparator = { 'left': "\ue0b0", 'right': "\ue0b2", 'font': "DejaVu Sans Mono for Powerline" }
let g:Lf_PreviewResult = {'Function': 0, 'BufTag': 0 }

let g:Lf_ShortcutF = '<Leader>ll'
noremap <Leader>lb :<C-U><C-R>=printf("Leaderf buffer --popup %s", "")<CR><CR>
noremap <Leader>lm :<C-U><C-R>=printf("Leaderf mru %s", "")<CR><CR>
noremap <Leader>lt :<C-U><C-R>=printf("Leaderf bufTag %s", "")<CR><CR>
noremap <Leader>la :<C-U><C-R>=printf("Leaderf line %s", "")<CR><CR>
noremap <Leader>lw :<C-U><C-R>=printf("Leaderf window --popup %s", "")<CR><CR>
noremap <Leader>lf :<C-U><C-R>=printf("Leaderf function %s", "")<CR><CR>
noremap <Leader>lc :<C-U><C-R>=printf("Leaderf command --popup %s", "")<CR><CR>
noremap <silent><Leader>lr :LeaderfRgInteractive<CR>
xnoremap gf :<C-U><C-R>=printf("Leaderf! rg -f -e %s ", leaderf#Rg#visual())<CR>
noremap go :<C-U>Leaderf! rg --recall<CR>
noremap <C-B> :<C-U><C-R>=printf("Leaderf! rg --current-buffer -e %s ", expand("<cword>"))<CR><CR>
noremap <C-F> :<C-U><C-R>=printf("Leaderf! rg -e %s ", expand("<cword>"))<CR><CR>
noremap <F5> :<C-U><C-R>=printf("Leaderf --nowrap --popup %s", "task")<CR><CR>

" defx
map <M-w> :Defx<CR>
call defx#custom#option('_', {
      \ 'winwidth': 50,
      \ 'split': 'floating',
      \ 'direction': 'botright',
      \ 'show_ignored_files': 0,
      \ 'buffer_name': 'DefxTree',
      \ 'toggle': 1,
      \ 'resume': 1,
      \})

autocmd FileType defx call s:defx_mappings()
autocmd BufWritePost * call defx#redraw()
function! s:defx_mappings() abort
    nnoremap <silent><buffer><expr> .       defx#do_action('toggle_ignored_files') 
    nnoremap <silent><buffer><expr> <C-r>   defx#do_action('redraw')
    nnoremap <silent><buffer><expr> o       <SID>defx_toggle_tree()
    nnoremap <silent><buffer><expr> c       defx#do_action('copy')
    nnoremap <silent><buffer><expr> m       defx#do_action('move')
    nnoremap <silent><buffer><expr> p       defx#do_action('paste')
    nnoremap <silent><buffer><expr> <CR>    defx#do_action('open_or_close_tree')
    nnoremap <silent><buffer><expr> q       defx#do_action('quit')
    nnoremap <silent><buffer><expr> E       defx#do_action('open', 'vsplit')
    nnoremap <silent><buffer><expr> t       defx#do_action('open', 'tabnew')
    nnoremap <silent><buffer><expr> k       defx#do_action('new_directory')
    nnoremap <silent><buffer><expr> n       defx#do_action('new_file')
    nnoremap <silent><buffer><expr> d       defx#do_action('remove')
    nnoremap <silent><buffer><expr> m       defx#do_action('new_multiple_files')
    nnoremap <silent><buffer><expr> r       defx#do_action('rename')
    nnoremap <silent><buffer><expr> !       defx#do_action('execute_command')
    nnoremap <silent><buffer><expr> yy      defx#do_action('yank_path')
    nnoremap <silent><buffer><expr> <C-g>   defx#do_action('print')
    nnoremap <silent><buffer><expr> h       defx#do_action('cd', ['..'])
    nnoremap <silent><buffer><expr> ~       defx#do_action('cd')
    nnoremap <silent><buffer><expr> <Space> defx#do_action('toggle_select') . 'j'
    nnoremap <silent><buffer><expr> *       defx#do_action('toggle_select_all')
    nnoremap <silent><buffer><expr> j       line('.') == line('$') ? 'gg' : 'j'
    nnoremap <silent><buffer><expr> k       line('.') == 1 ? 'G' : 'k'
    "nnoremap <silent><buffer><expr> C       defx#do_action('toggle_columns', "'mark:indent:icon:filename:type:size:time')
    nnoremap <silent><buffer><expr> S       defx#do_action('toggle_sort', 'time')
    nnoremap <silent><buffer><expr> x       defx#do_action('execute_system')
    "nnoremap <silent><buffer><expr> ;       defx#do_action('repeat')
endfunction

function! s:defx_toggle_tree() abort
    " Open current file, or toggle directory expand/collapse
    if defx#is_directory()
        return defx#do_action('open_or_close_tree')
    endif
    return defx#do_action('multi', ['drop'])
endfunction

" ------------------depend-----------------
" auto fcitx
" let g:input_toggle = 1
function! Fcitx2en()
   let s:input_status = system("fcitx-remote")
   if s:input_status == 2
      " let g:input_toggle = 1
      let l:a = system("fcitx-remote -c")
   endif
endfunction

" function! Fcitx2zh()
"    let s:input_status = system("fcitx-remote")
"    if s:input_status != 2 && g:input_toggle == 1
"       let l:a = system("fcitx-remote -o")
"       let g:input_toggle = 0
"    endif
" endfunction

set ttimeoutlen=150
"退出插入模式
autocmd InsertLeave * call Fcitx2en()
"进入插入模式
" autocmd InsertEnter * call Fcitx2zh()

" fzf
nnoremap <silent> <Leader>vf :Files<CR>
nnoremap <silent> <Leader>vL :Locate<Space>
nnoremap <silent> <Leader>vgf :GFiles<CR>
nnoremap <silent> <Leader>vl :Lines<CR>
nnoremap <silent> <Leader>vbl :BLines<CR>
nnoremap <silent> <Leader>va :Rg<CR>
nnoremap <silent> <Leader>vm :Marks<CR>
nnoremap <silent> <Leader>vh :Maps<CR>
nnoremap <silent> <Leader>vr :<C-U><C-R>=printf("Rg %s ", expand("<cword>"))<CR><CR>
" [Buffers] Jump to the existing window if possible
let g:fzf_buffers_jump = 1
" [[B]Commits] Customize the options used by 'git log':
let g:fzf_commits_log_options = '--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"'
" [Tags] Command to generate tags file
let g:fzf_tags_command = 'ctags -R'
" [Commands] --expect expression for directly executing the command
let g:fzf_commands_expect = 'alt-enter,ctrl-x'
" ag
command! -bang -nargs=* Ag
            \ call fzf#vim#ag(<q-args>,
            \                 <bang>0 ? fzf#vim#with_preview('up:60%')
            \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
            \                 <bang>0)


" F
command! -nargs=1 Rename let tpname = expand('%:t') | saveas <args> | edit <args> | call delete(expand(tpname))
map <F2> :Rename<space>

" coc
" the 4000 default will have bad experience for diagnostic messages
set updatetime=100
set signcolumn =yes
" 高亮高标下的单词
autocmd CursorHold * silent call CocActionAsync('highlight')
" Remap for format selected region
xmap <leader>fm  <Plug>(coc-format-selected)
nmap <leader>fm  <Plug>(coc-format-selected)
" Add status line support, for integration with other plugin, checkout `:h coc-status`
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}
" navigate diagnostics
nmap <silent>[g <Plug>(coc-diagnostic-prev)
nmap <silent>]g <Plug>(coc-diagnostic-next)
" Remap keys for gotos
nmap <silent><Leader>dd <Plug>(coc-definition)
nmap <silent><Leader>dt <Plug>(coc-type-definition)
nmap <silent><Leader>di <Plug>(coc-implementation)
nmap <silent><Leader>dr <Plug>(coc-references)
" Use K to show documentation in preview window.
nnoremap <silent><Leader>ok :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction
" Symbol renaming.
nmap <leader>or <Plug>(coc-rename)
" Show all diagnostics.
nnoremap <leader>oe  :<C-u>CocList diagnostics<cr>
" Find symbol of current document.
nnoremap <leader>oo  :<C-u>CocList outline<cr>
" Search workspace symbols.
nnoremap <leader>os  :<C-u>CocList -I symbols<cr>
" tags
nnoremap <leader>ot  :<C-u>CocList tags<cr>
" files
nnoremap <leader>os  :<C-u>CocList files<cr>
" colors
nnoremap <leader>oc :<C-u>CocList colors<CR>

augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end
" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}
" Apply AutoFix to problem on the current line.
nmap <leader>.  <Plug>(coc-fix-current)
